通用寄存器读写，内存读写
AX--->16位--->16/4  4个16进制数
AL--->32位--->32/4  8个16进制数
AL--->8位 ---->8/4  2个16进制数

mov eax,0xAAAA AAAA   //操作码 目标操作数 源操作数/立即数

字符指针与字符数组的区别:
char str[10]="tasklist";
char *p="tasklist";
printf("%p,%p",str,p);

1.寄存器读写：
1.1---8个通用寄存器:
EAX [31,0]
	AX(AH [15,7],AL [7,0]) [15,0]
ECX
	CX(CH,CL)
EDX
	DX(DH,DL)
EBX
	BX(BH,BL)
ESP
EBP
ESI
EDI
1.2 32位寄存器的读写
mov eax,BBBBBBB
;EAX 0BBBBBBB
mov eax,0xAAAAAAAA  ;32位二进制，也就是32/4=8个十六进制数。
;EAX AAAAAAAA
mov eax,0xCCCCCCCCC
;调试器报错，无法调试

1.3 16位寄存器的读写
mov eax,0x11111111 ;重置eax中的值。

mov AX,0xBBB
;EAX 11110BBB
mov AX,0xAAAA  ;16位二进制，也就是16/4=4个十六进制数。
;EAX 1111AAAA
mox AX,0XCCCCC
;调试器报错，无法调试。即使不报错，高四位依然还是1，不会被覆盖。

1.4 8位寄存器的读写
mov eax,0x11111111 ;重置eax中的值。

mov AH,0xB 
;EAX 11110B11
mov AH,0XAA	;8位二进制，也就是8/4=2个十六进制数。
;EAX 1111AA11
mov AH,0xCCC 
;调试器报错，无法调试。即使不报错，高四位地址也不会受影响。

mov eax,0x11112222 ;重置eax中的值。
;EAX 11112222

mov al,0xB
;EAX 1111220B
mov al,0xAA ;8位二进制，也就是8/4=2个16进制数。
;EAX 111122AA
mov al,0xCCC
;调试器报错，无法调试。即使不报错,高二位的地址，也依然是2，不会被覆盖。

2.内存读写:
2.1 内存的格式
32位的内存地址范围：						
0x00000000(8个十六进制数。)
.......
.......
0xFFFFFFFF
每个内存单元的宽度为8位，也就是1字节。
7.......0

2.2 向内存中读写数据
2.2.1 把立即数写入内存:
mov 读写的数据大小 数值的含义 段寄存器:[数值],十六进制数值
mov dword ptr ds:[0x0012FF34],0x11112222 ;向内存中写入数据
;dword表示要读写4字节
;ptr表示后面的数值是个指针,是一个地址值。
;0x0012FF34是一块内存地址。这块内存不是随便找的，必须在栈窗口中找。
;0x11112222是待操作的一个数据。
;注意观察，右下角栈窗口中的该地址所对应的值，已经发生了变化。
2.2.2 把寄存器中的值写入内存：
mov eax,0x66667777
;EAX 66667777
mov dword ptr ds:[0x0012FF34],eax
;0x0012FF34 66667777

2.3 读取内存中的值
2.3.1 把内存中的值读取到寄存器中[直接使用立即数地址]
mov eax,dword ptr ds:[0x0012FF34]  ;把内存中的数据读取到eax寄存器中。
;EAX 11112222 
;查看寄存器窗口中的EAX寄存器的值已经发生了变化。
2.3.2 使用寄存器的值
mov dword ptr ds:[0x0012f324],0x99998888 ;把内存地址是..f324的值初始化为99998888
;0x0012f324 99998888
mov ecx,0x0012f324 ;把初始化完毕的内存地址值传给ecx寄存器
;ECX 0x0012F324
mov eax,dword ptr ds:[ecx] ;把内存地址是0x0012f324的值传给ecx
;ECX 99998888

2.4 获取内存编号
lea eax,dword ptr ds:[0x31FFC4] ;把内存地址读取到eax寄存器中
lea eax,dword ptr ds:[esp+8]
