特殊寄存器: 不同的处理机个数和结构都不同。
	标志寄存器(8086CPU体系结构中的)--->flag。同ax,cx,dx,bx...一样。
	
共性:
	用来存储相关指令的某些执行结构
	用来为CPU执行相关指令提供行为依据
	用来控制CPU的相关方式
	
标志寄存器共有16位，其中存储的状态信息称为程序状态字(PSW)。
ax,cx,dx,bc....这些寄存器是用来存放数据的，整个寄存器具有一个含义。
flag寄存器是按位其作用的，每一位都有专门的含义。
	flag寄存器结构: .....OF,DF,IF,TF,SF,ZF..,AF..PF..CF(0)

11 OF
10 DF
9  IF
8  TF
7  SF

6  ZF 
4  AF
2  PF 
0  CF

影响标志寄存器的指令: add,sub,mul,div,inc,or,and 大多是运算指令，逻辑运算或算术运算。
不影响标志寄存器的指令:mov ,push,pop 大多是传送指令。
在计算机中，1表示逻辑真，0表示逻辑假false

ZF->零标志位。zf位判断执行结果是否为0。
记录相关指令执行后，结果为0，那么zf=1；结果不为0，那么zf=0
eg：
mov eax,1 
sub eax,1  --->eax=eax-1 结果为0，所以zf=1 

mov ax,2
sub ax,1 --->ax =ax -1 结果非0，为1，所以zf=0

PF->奇偶标志位。pf位判断结果中1的个数。 
记录相关指令执行后,其结果所有的二进制位中1的个数，如果1的个数是偶数，那么pf=1;1的个数就是奇数，那么pf=0。0属于偶数。
eg:
	mov al,1  -->0001
	add al,10  --->0001 + 00001010 = 00001011 结果是3个1，是奇数，所以pf=0
		
	mov al,1 --->0001
	add al,2 --->0001 + 0010 =0011 结果是2个1，是偶数，所以pf=1 
	
SF->符号标志位。sf判断结果的正负。在有符号运算时，才有意义。
记录执行相关指令后，其结果为负，sf=1,其结果非负，sf=0 

同一个二进制数，有两种解读方式:
10000001B--->129 当看作无符号数的时候，它是129
		 --->-127 当看作有符号数的时候，它是-127
所以，sf标志位虽然会随着运算进行变化，但是只有当你打算把数字解读为有符号数的时候，它才有意义，他的1才表示结果为负。
eg:
	mov a1,10000001B 
	add a1,1  --->10000010B (-130) 结果为负数，所以sf=1 
	
CF->进位标志位。cf判断最高位是否进位或借位。只针对无符号数有意义。
在进行无符号数运算时，记录了对运算结果的最高有效位向更高位的进位或借位值。如果产生了进位或借位，那么cf为1，否则为0.
eg:
	mov al,0xEF --->11101111
	add al,2  -->11101111 + 0010 = 11110001 最高有效位没有产生进位，cf=0 
	
	mov al,0xFE --->11111110 
	add al,2 -->11111110 + 0010 = 00000000 产生了进位,cf=1 

OF->溢出标志位。判断结果是否发生了溢出。只针对有符号数有意义。
记录了有符号数的运算结果是否发生了溢出，发生溢出of=1;没有溢出of=0

	