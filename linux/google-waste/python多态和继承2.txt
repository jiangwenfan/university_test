多继承：
可以继承多个类，如果每个类都定义了相同的函数，那么其寻找的方式有两种，
是：深度优先和广度优先。
经典类(深度优先)；
class C1:   //c1是经典类
	pass
class C2(C1):  //c2是经典类
	pass

新式类(广度优先)；当前类 或者 父类 继承object类
class N1(object):	//N1是新式类
	pass
class N2(N1):	.//N2是新式类
	pass
查找的过程中，一旦找到，则寻找的过程立即中断，便不会继续找了。

多态：
python不支持Java和c#这一类强类型语言中多态的写法，但是原生多态，崇尚“鸭子类型”
python鸭子类型的多态：
class F1:
	pass
class S1(F1):
	def show(self):
		print 's1.show'
class S2(F1):
	def show(self):
		print 's2.show'
#a=S1()
#a.show()  //直接手动调用.show()方法
#b=S2()
#b.show()
#
def func(obj):
	print obj.show()
b_obj=s2()
func(b_obj)   //只传入参数，函数调用.show()方法。

a_obj=s1()
func(a_obj)   //a_obj.show() === a.show()

访问限制：
NO.1: [未完待续]
class Student(object):
	def __init__(self,name,score):
		self.name=name
		self.score=score
bart=Student('tony',59)
bart.score   #查看实例的属性
bart.score=99 #修改实例的属性
bart.score   #再次查看实例的属性

NO.2:  不能获取实例属性。
如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__。实例的变量名前如果以__开头，
就变成了一个私有变量(private),只有内部可以访问，外部不可以访问。
class Student(object):
	def __init__(self,name,score):
		self.__name=name
		self.__score=score
	def print_score(self):
		print('%s:%s'%(self.__name,self.__score))
bart=Student('tony',59)
bart.print_score()
bart.__score  #外部已经无访问了

NO.3: 有想获取实例属性。
class Student(object):
	def__init__(self,name,score):
		self.__name=name
		self.__score=score
	def print_score(self):
		print('%s:%s'%(self.__name,self.__score))
	def get_name(self):
		return self.__name
	def get_score(self):
		return self.__score
bart=Student('tony',59)
bart.print_score()
self_name = bart.get_name()              #实现了外部代码获取实例属性
self_score = bart.get_score()
print(self_name,self_score)        

NO.4:   修改实例属性
class Student(object):
	def __init__(self,name,score):
		self.__name=name
		self.__score=score
	def print_score(self):
		print('%s:%s'%(self.__name,self.__score))
	def get_name(self):
		return self.__name
	def get_score(self):
		return self.__score
	def set_score(self,score):   #修改实例属性
		self.__score=score
	def set_name(self,name):
		self.__name=name
bart=Student('tony',59)
bart.print_score()
new_score=bart.set_score(99)
new_name=bart.set_name('jarvis')
print(new_score,new_name)
	
获取对象信息：
NO.1：(未完待续)
type()函数：判断对象类型
type('abc') --->str
type('abs') ---->str
type(abs) ----->function(函数)
type(123)  ---->int
判断比较：
type(123)==type(456)
type(123)==int
type(123)==type('abc')
type(123)==type(abc)  #报错，因为没有abc这个函数。
type(123)==str
使用types模块判断一个对象是否是函数(多此一举)
import types
def fn():
	pass
type(fn)==types.FunctionType
type(abs)==types.BuiltinFunctionType
type(lambda x:x)==types.LambdaType
type((x for x in range(10))) ==types.GeneratorType
简单判断：
def fn():
	pass
type(fn)

NO.2 ***[优先使用这个isinstance()，高于type()]***
要判断Class类型，优先使用isinstance()
先创建三种类型的对象(实例)：
a=Animal()
d=Dog()
h=Husky()
然后判断：
isinstance(h,Husky) ---->True
isinstance(h,Dog)
isinstance(h,Animal)
isinstance(d,Dog) and isinstance(d,Animal) --->True
isinatance(d,Husky) --->False
判断基本类型：
isinstance('a',str)
isinstance(123,int)
isinstance(b'a',bytes)
判断一个变量是否是某些类型中的一种，eg:判断是否是list或者tuple
isinstance([1,2,3],(list,tuple))
isinstance((1,2,3),(list,typle))
isinstance([1,2,3],list)


继承和多态：
当已经定义一个class的时候，可以从现有的class继承，新的class称为子类(subclass),而被继承的类称为基类，
父类(base class)或者超类(super class)。
继承最大的好处就是：子类获得了父类的全部功能
class Animal(object):       #父类，基类
	def run(self):
		print('Animal is running....')
		
class Dog(Animal):    #子类。从父类(基类)Animal中继承
	pass
class Cat(Animal):
	cass

继承实例：
class Animal:
	def eat(self):
		print "%s 吃"%self.name
	def drink(self):
		print "%s 喝"%self.name
	def shift(self):
		print "%s 啦"%self.name
	def pee(self):
		print "%s 撒"%self.name
class Cat(Animal):
	def __init__(self,name)
		slef.name=name
		self.breed='猫'  //派生出了新属性
	def cry(self):
		print '喵喵叫'
class Dog(Animal):
	def __init__(self,name):
		self.name=name
		self.breed='狗'
	def cry(self):
		print '汪汪叫'
c1=Cat('黑猫')
c1.eat()
c2=Cat('白猫')
c2.drink()
c2.cry()
经典类 多继承：  //深度查找
class D:
	def bar(self):
		print 'D.der'
class C(D):
	def bar(self):
		print 'c.bar'
class B(D):
	def bar(self):
		print 'B.bar'
class A(B,C):
	def bar(self):
		print 'A.bar'
a=A()
a.bar()
新式类 多继承：  //广度查找
class D(object):
	def bar(self):
		print 'D.bar'
class C(D):
	def bar(self):
		print 'C.bar'
class B(D)：
	def bar(self):
		print 'B.bar'
class A(B,C):
	def bar(self):
		print 'A.bar'
a=A()
a.bar()

	











